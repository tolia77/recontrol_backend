<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/controllers/concerns/authentication.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/concerns/authentication.rb" />
              <option name="originalContent" value="# frozen_string_literal: true&#10;&#10;module Authentication&#10;  extend ActiveSupport::Concern&#10;&#10;  def authorized?&#10;    if request.headers[&quot;X-Service-Token&quot;] == ENV[&quot;SERVICE_TOKEN&quot;]&#10;      return true&#10;    end&#10;    access_token = request.headers[&quot;Authorization&quot;]&amp;.split(&quot; &quot;)&amp;.last || cookies.encrypted[:access_token]&#10;    refresh_token = request.headers[&quot;Refresh-Token&quot;]&amp;.split(&quot; &quot;)&amp;.last || cookies.encrypted[:refresh_token]&#10;    return false unless access_token &amp;&amp; refresh_token&#10;    begin&#10;      # Verify access token first (faster check)&#10;      access_payload = JWTUtils.decode_access(access_token)&#10;      user_id = access_payload[0][&quot;sub&quot;]&#10;      jti = access_payload[0][&quot;jti&quot;]&#10;      session_key = access_payload[0][&quot;session_key&quot;]&#10;      session = Session.find_by(&#10;        user_id: user_id,&#10;        jti: jti,&#10;        session_key: session_key,&#10;        status: &quot;active&quot;&#10;      )&#10;      return true if session.present? &amp;&amp; session.expires_at &gt; Time.current&#10;&#10;      # If access token is invalid, try refresh token&#10;      refresh_payload = JWTUtils.decode_refresh(refresh_token)&#10;      user_id = refresh_payload[0][&quot;sub&quot;]&#10;      jti = refresh_payload[0][&quot;jti&quot;]&#10;      session_key = refresh_payload[0][&quot;session_key&quot;]&#10;&#10;      session = Session.find_by(&#10;        user_id: user_id,&#10;        jti: jti,&#10;        session_key: session_key,&#10;        status: &quot;active&quot;&#10;      )&#10;&#10;      session.present? &amp;&amp; session.expires_at &gt; Time.current&#10;    rescue JWT::DecodeError, JWT::ExpiredSignature&#10;      false&#10;    end&#10;  end&#10;&#10;  def current_user&#10;    return unless authorized?&#10;&#10;    access_token = request.headers[&quot;Authorization&quot;]&amp;.split(&quot; &quot;)&amp;.last || cookies.encrypted[:access_token]&#10;    begin&#10;      payload = JWTUtils.decode_access(access_token)&#10;      User.find_by(id: payload[0][&quot;sub&quot;])&#10;    rescue JWT::DecodeError, JWT::ExpiredSignature&#10;      nil&#10;    end&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="# frozen_string_literal: true&#10;&#10;module Authentication&#10;  extend ActiveSupport::Concern&#10;&#10;  def authorized?&#10;    if request.headers[&quot;X-Service-Token&quot;] == ENV[&quot;SERVICE_TOKEN&quot;]&#10;      return true&#10;    end&#10;    access_token = request.headers[&quot;Authorization&quot;]&amp;.split(&quot; &quot;)&amp;.last || cookies.encrypted[:access_token]&#10;    refresh_token = request.headers[&quot;Refresh-Token&quot;]&amp;.split(&quot; &quot;)&amp;.last || cookies.encrypted[:refresh_token]&#10;    return false unless access_token &amp;&amp; refresh_token&#10;    begin&#10;      # Verify access token first (faster check)&#10;      access_payload = JWTUtils.decode_access(access_token)&#10;      user_id = access_payload[0][&quot;sub&quot;]&#10;      jti = access_payload[0][&quot;jti&quot;]&#10;      session_key = access_payload[0][&quot;session_key&quot;]&#10;      session = Session.find_by(&#10;        user_id: user_id,&#10;        jti: jti,&#10;        session_key: session_key,&#10;        status: &quot;active&quot;&#10;      )&#10;      return true if session.present? &amp;&amp; session.expires_at &gt; Time.current&#10;&#10;      # If access token is invalid, try refresh token&#10;      refresh_payload = JWTUtils.decode_refresh(refresh_token)&#10;      user_id = refresh_payload[0][&quot;sub&quot;]&#10;      jti = refresh_payload[0][&quot;jti&quot;]&#10;      session_key = refresh_payload[0][&quot;session_key&quot;]&#10;&#10;      session = Session.find_by(&#10;        user_id: user_id,&#10;        jti: jti,&#10;        session_key: session_key,&#10;        status: &quot;active&quot;&#10;      )&#10;&#10;      session.present? &amp;&amp; session.expires_at &gt; Time.current&#10;    rescue JWT::DecodeError, JWT::ExpiredSignature&#10;      false&#10;    end&#10;  end&#10;&#10;  def current_user&#10;    return unless authorized?&#10;&#10;    access_token = request.headers[&quot;Authorization&quot;]&amp;.split(&quot; &quot;)&amp;.last || cookies.encrypted[:access_token]&#10;    begin&#10;      payload = JWTUtils.decode_access(access_token)&#10;      User.find_by(id: payload[0][&quot;sub&quot;])&#10;    rescue JWT::DecodeError, JWT::ExpiredSignature&#10;      nil&#10;    end&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/models/session.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/models/session.rb" />
              <option name="originalContent" value="class Session &lt; ApplicationRecord&#10;  belongs_to :user, required: true&#10;  belongs_to :device, optional: true&#10;  before_create :set_initial_values&#10;  enum :status, %i[active revoked]&#10;  attribute :status, default: &quot;active&quot;&#10;  private&#10;&#10;  def set_initial_values&#10;    self.jti ||= SecureRandom.uuid&#10;    self.session_key ||= SecureRandom.uuid&#10;    self.expires_at ||= ENV[&quot;JWT_REFRESH_EXPIRATION_DAYS&quot;].to_i.days.from_now&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="class Session &lt; ApplicationRecord&#10;  belongs_to :user, required: true&#10;  belongs_to :device, optional: true&#10;  before_create :set_initial_values&#10;  enum :status, %i[active revoked]&#10;  attribute :status, default: &quot;active&quot;&#10;  private&#10;&#10;  def set_initial_values&#10;    self.jti ||= SecureRandom.uuid&#10;    self.session_key ||= SecureRandom.uuid&#10;    self.expires_at ||= ENV[&quot;JWT_REFRESH_EXPIRATION_DAYS&quot;].to_i.days.from_now&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>