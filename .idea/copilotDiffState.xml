<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/controllers/auth_controller.rb">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/controllers/auth_controller.rb" />
              <option name="originalContent" value="class AuthController &lt; ApplicationController&#10;  ACCESS_EXP_MIN = ENV[&quot;JWT_ACCESS_EXPIRATION_MINUTES&quot;].to_i&#10;  REFRESH_EXP_DAYS = ENV[&quot;JWT_REFRESH_EXPIRATION_DAYS&quot;].to_i&#10;  def login&#10;    email = params[:email]&#10;    password = params[:password]&#10;    client_type = params[:client_type] || &quot;web&quot;&#10;    user = User.find_by(email: email)&#10;    if user&amp;.authenticate(password)&#10;      session = Session.new(user: user, client_type: client_type)&#10;      if session.save&#10;        access_token = JWTUtils.encode_access(&#10;          {&#10;            sub: user.id,&#10;            device_id: session.device_id,&#10;            jti: session.jti,&#10;            session_key: session.session_key,&#10;            exp: ACCESS_EXP_MIN.minutes.from_now.to_i&#10;          }&#10;        )&#10;        refresh_token = JWTUtils.encode_refresh(&#10;          {&#10;            sub: user.id,&#10;            device_id: session.device_id,&#10;            jti: session.jti,&#10;            session_key: session.session_key,&#10;            exp: session.expires_at.to_i&#10;          }&#10;        )&#10;        set_auth_cookies(access_token, refresh_token)&#10;        render json: { user_id: user.id, access_token: access_token, refresh_token: refresh_token }, status: :ok&#10;      else&#10;        render json: { error: &quot;Failed to create session&quot; }, status: :internal_server_error&#10;      end&#10;    else&#10;      render json: { error: &quot;Invalid email or password&quot; }, status: :unauthorized&#10;    end&#10;  end&#10;&#10;  def register&#10;  end&#10;&#10;  def logout&#10;  end&#10;&#10;  def refresh&#10;  end&#10;&#10;  private&#10;  def user_params&#10;    params.require(:user).permit(:email, :password, :username)&#10;  end&#10;  def set_auth_cookies(access_token, refresh_token)&#10;    cookies.encrypted[:access_token] = {&#10;      value: access_token,&#10;      httponly: true,&#10;      secure: ENV[&quot;USE_SECURE_COOKIES&quot;] == &quot;true&quot;,&#10;      same_site: :none,&#10;      expires: ACCESS_EXP_MIN.minutes.from_now&#10;    }&#10;&#10;    cookies.encrypted[:refresh_token] = {&#10;      value: refresh_token,&#10;      httponly: true,&#10;      secure: ENV[&quot;USE_SECURE_COOKIES&quot;] == &quot;true&quot;,&#10;      same_site: :none,&#10;      expires: REFRESH_EXP_DAYS.days.from_now&#10;    }&#10;  end&#10;end&#10;" />
              <option name="updatedContent" value="class AuthController &lt; ApplicationController&#10;  ACCESS_EXP_MIN = ENV[&quot;JWT_ACCESS_EXPIRATION_MINUTES&quot;].to_i&#10;  REFRESH_EXP_DAYS = ENV[&quot;JWT_REFRESH_EXPIRATION_DAYS&quot;].to_i&#10;  def login&#10;    email = params[:email]&#10;    password = params[:password]&#10;    client_type = params[:client_type] || &quot;web&quot;&#10;    device_id = params[:device_id] # may be nil for non-desktop clients&#10;&#10;    user = User.find_by(email: email)&#10;    if user&amp;.authenticate(password)&#10;      # If desktop client, require device_id and verify the device belongs to the user&#10;      if client_type == &quot;desktop&quot;&#10;        if device_id.blank?&#10;          render json: { error: &quot;device_id is required for desktop clients&quot; }, status: :bad_request and return&#10;        end&#10;&#10;        device = user.devices.find_by(id: device_id)&#10;        unless device&#10;          render json: { error: &quot;Invalid device_id&quot; }, status: :bad_request and return&#10;        end&#10;&#10;        session = Session.new(user: user, client_type: client_type, device: device)&#10;      else&#10;        session = Session.new(user: user, client_type: client_type)&#10;      end&#10;&#10;      if session.save&#10;        # Build base payloads and conditionally add device_id for desktop clients&#10;        access_payload = {&#10;          sub: user.id,&#10;          jti: session.jti,&#10;          session_key: session.session_key,&#10;          exp: ACCESS_EXP_MIN.minutes.from_now.to_i&#10;        }&#10;        refresh_payload = {&#10;          sub: user.id,&#10;          jti: session.jti,&#10;          session_key: session.session_key,&#10;          exp: session.expires_at.to_i&#10;        }&#10;&#10;        if client_type == &quot;desktop&quot;&#10;          access_payload[:device_id] = session.device_id&#10;          refresh_payload[:device_id] = session.device_id&#10;        end&#10;&#10;        access_token = JWTUtils.encode_access(access_payload)&#10;        refresh_token = JWTUtils.encode_refresh(refresh_payload)&#10;&#10;        set_auth_cookies(access_token, refresh_token)&#10;        render json: { user_id: user.id, access_token: access_token, refresh_token: refresh_token }, status: :ok&#10;      else&#10;        render json: { error: &quot;Failed to create session&quot; }, status: :internal_server_error&#10;      end&#10;    else&#10;      render json: { error: &quot;Invalid email or password&quot; }, status: :unauthorized&#10;    end&#10;  end&#10;&#10;  def register&#10;  end&#10;&#10;  def logout&#10;  end&#10;&#10;  def refresh&#10;  end&#10;&#10;  private&#10;  def user_params&#10;    params.require(:user).permit(:email, :password, :username)&#10;  end&#10;  def set_auth_cookies(access_token, refresh_token)&#10;    cookies.encrypted[:access_token] = {&#10;      value: access_token,&#10;      httponly: true,&#10;      secure: ENV[&quot;USE_SECURE_COOKIES&quot;] == &quot;true&quot;,&#10;      same_site: :none,&#10;      expires: ACCESS_EXP_MIN.minutes.from_now&#10;    }&#10;&#10;    cookies.encrypted[:refresh_token] = {&#10;      value: refresh_token,&#10;      httponly: true,&#10;      secure: ENV[&quot;USE_SECURE_COOKIES&quot;] == &quot;true&quot;,&#10;      same_site: :none,&#10;      expires: REFRESH_EXP_DAYS.days.from_now&#10;    }&#10;  end&#10;end" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>